import 'package:grpc/grpc.dart';
import 'package:nordvpn/data/providers/app_state_provider.dart';
import 'package:nordvpn/data/repository/account_repository.dart';
import 'package:nordvpn/data/repository/daemon_status_codes.dart';
import 'package:nordvpn/internal/dates_util.dart';
import 'package:nordvpn/logger.dart';
import 'package:nordvpn/pb/daemon/state.pb.dart';
import 'package:nordvpn/pb/daemon/token.pb.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'token_info_provider.g.dart';

// This fetches and stores the token information generated by the daemon
// Token are needed when user tries to access some services and are added into
// the service URL
@Riverpod(keepAlive: true)
final class TokenInfo extends _$TokenInfo implements AccountObserver {
  @override
  FutureOr<TokenInfoResponse?> build() async {
    _registerAccountNotifications();
    return await _fetchTokenInfo();
  }

  void _registerAccountNotifications() {
    final notification = ref.read(appStateProvider);
    notification.addAccountObserver(this);
    ref.onDispose(() {
      notification.removeAccountObserver(this);
    });
  }

  Future<TokenInfoResponse?> _fetchTokenInfo() async {
    int status = DaemonStatusCode.success;
    try {
      // This gRPC uses mostly status codes to signal errors
      // The only exception thrown should be NotLoggedIn
      // We do not want to popup errors from here, just logs
      final tokenInfo = await ref.read(accountRepositoryProvider).tokenInfo();
      if (tokenInfo.type.toInt() == DaemonStatusCode.success) {
        return tokenInfo;
      }
      status = tokenInfo.type.toInt();
      logger.e("failed to fetch token info $status");
    } on GrpcError catch (e) {
      status = DaemonStatusCode.fromGrpcError(e);
      logger.e("failed to fetch token info with gRPC $e and $status");
    } catch (e) {
      status = DaemonStatusCode.failure;
      logger.e("failed to fetch token info $e");
    }

    return null;
  }

  Future<void> _updateToken() async {
    state = AsyncData(await _fetchTokenInfo());
  }

  // Append the token info if it is available.
  // When tokens are invalid or empty starts an async re-fetch to be available
  // next time the function is called
  Future<Uri> addTokenInfo(Uri uri) async {
    await future; // wait until build method is executed
    if (state is AsyncData && (state.value != null)) {
      final token = state.value!;
      final expirationDate = parseDate(token.expiresAt);
      final isTokenExpired =
          (expirationDate != null) && expirationDate.isBefore(DateTime.now());

      if (!isTokenExpired &&
          token.trustedPassOwnerId.isNotEmpty &&
          token.trustedPassToken.isNotEmpty) {
        return uri.replace(
          queryParameters: {
            ...uri.queryParameters,
            'trusted_pass_token': token.trustedPassToken,
            'owner_id': token.trustedPassOwnerId,
          },
        );
      }
    }

    // start an async refresh of the token
    _updateToken();
    return uri;
  }

  @override
  void onAccountChanged(LoginEventType type) {
    if (type == LoginEventType.LOGOUT) {
      state = AsyncData(null);
    } else {
      _updateToken();
    }
  }

  @override
  void onAccountModified(AccountModification accountModification) {
    _updateToken();
  }
}
