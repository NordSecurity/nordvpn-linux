// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.6
// source: protobuf/daemon/service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Daemon_AccountInfo_FullMethodName             = "/pb.Daemon/AccountInfo"
	Daemon_TokenInfo_FullMethodName               = "/pb.Daemon/TokenInfo"
	Daemon_Cities_FullMethodName                  = "/pb.Daemon/Cities"
	Daemon_Connect_FullMethodName                 = "/pb.Daemon/Connect"
	Daemon_ConnectCancel_FullMethodName           = "/pb.Daemon/ConnectCancel"
	Daemon_Countries_FullMethodName               = "/pb.Daemon/Countries"
	Daemon_Disconnect_FullMethodName              = "/pb.Daemon/Disconnect"
	Daemon_Groups_FullMethodName                  = "/pb.Daemon/Groups"
	Daemon_IsLoggedIn_FullMethodName              = "/pb.Daemon/IsLoggedIn"
	Daemon_LoginWithToken_FullMethodName          = "/pb.Daemon/LoginWithToken"
	Daemon_LoginOAuth2_FullMethodName             = "/pb.Daemon/LoginOAuth2"
	Daemon_LoginOAuth2Callback_FullMethodName     = "/pb.Daemon/LoginOAuth2Callback"
	Daemon_Logout_FullMethodName                  = "/pb.Daemon/Logout"
	Daemon_Ping_FullMethodName                    = "/pb.Daemon/Ping"
	Daemon_RateConnection_FullMethodName          = "/pb.Daemon/RateConnection"
	Daemon_SetAutoConnect_FullMethodName          = "/pb.Daemon/SetAutoConnect"
	Daemon_SetThreatProtectionLite_FullMethodName = "/pb.Daemon/SetThreatProtectionLite"
	Daemon_SetDefaults_FullMethodName             = "/pb.Daemon/SetDefaults"
	Daemon_SetDNS_FullMethodName                  = "/pb.Daemon/SetDNS"
	Daemon_SetFirewall_FullMethodName             = "/pb.Daemon/SetFirewall"
	Daemon_SetFirewallMark_FullMethodName         = "/pb.Daemon/SetFirewallMark"
	Daemon_SetRouting_FullMethodName              = "/pb.Daemon/SetRouting"
	Daemon_SetAnalytics_FullMethodName            = "/pb.Daemon/SetAnalytics"
	Daemon_SetKillSwitch_FullMethodName           = "/pb.Daemon/SetKillSwitch"
	Daemon_SetNotify_FullMethodName               = "/pb.Daemon/SetNotify"
	Daemon_SetTray_FullMethodName                 = "/pb.Daemon/SetTray"
	Daemon_SetObfuscate_FullMethodName            = "/pb.Daemon/SetObfuscate"
	Daemon_SetProtocol_FullMethodName             = "/pb.Daemon/SetProtocol"
	Daemon_SetTechnology_FullMethodName           = "/pb.Daemon/SetTechnology"
	Daemon_SetLANDiscovery_FullMethodName         = "/pb.Daemon/SetLANDiscovery"
	Daemon_SetAllowlist_FullMethodName            = "/pb.Daemon/SetAllowlist"
	Daemon_UnsetAllowlist_FullMethodName          = "/pb.Daemon/UnsetAllowlist"
	Daemon_UnsetAllAllowlist_FullMethodName       = "/pb.Daemon/UnsetAllAllowlist"
	Daemon_Settings_FullMethodName                = "/pb.Daemon/Settings"
	Daemon_SettingsProtocols_FullMethodName       = "/pb.Daemon/SettingsProtocols"
	Daemon_SettingsTechnologies_FullMethodName    = "/pb.Daemon/SettingsTechnologies"
	Daemon_Status_FullMethodName                  = "/pb.Daemon/Status"
	Daemon_SetIpv6_FullMethodName                 = "/pb.Daemon/SetIpv6"
	Daemon_ClaimOnlinePurchase_FullMethodName     = "/pb.Daemon/ClaimOnlinePurchase"
	Daemon_SetVirtualLocation_FullMethodName      = "/pb.Daemon/SetVirtualLocation"
	Daemon_SubscribeToStateChanges_FullMethodName = "/pb.Daemon/SubscribeToStateChanges"
	Daemon_GetServers_FullMethodName              = "/pb.Daemon/GetServers"
	Daemon_SetPostQuantum_FullMethodName          = "/pb.Daemon/SetPostQuantum"
	Daemon_IsNordWhisperEnabled_FullMethodName    = "/pb.Daemon/IsNordWhisperEnabled"
	Daemon_GetDaemonApiVersion_FullMethodName     = "/pb.Daemon/GetDaemonApiVersion"
)

// DaemonClient is the client API for Daemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DaemonClient interface {
	AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountResponse, error)
	TokenInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TokenInfoResponse, error)
	Cities(ctx context.Context, in *CitiesRequest, opts ...grpc.CallOption) (*ServerGroupsList, error)
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Payload], error)
	ConnectCancel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	Countries(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error)
	Disconnect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Payload], error)
	Groups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error)
	IsLoggedIn(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bool, error)
	LoginWithToken(ctx context.Context, in *LoginWithTokenRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	LoginOAuth2(ctx context.Context, in *LoginOAuth2Request, opts ...grpc.CallOption) (*LoginOAuth2Response, error)
	LoginOAuth2Callback(ctx context.Context, in *LoginOAuth2CallbackRequest, opts ...grpc.CallOption) (*Empty, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Payload, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResponse, error)
	RateConnection(ctx context.Context, in *RateRequest, opts ...grpc.CallOption) (*Payload, error)
	SetAutoConnect(ctx context.Context, in *SetAutoconnectRequest, opts ...grpc.CallOption) (*Payload, error)
	SetThreatProtectionLite(ctx context.Context, in *SetThreatProtectionLiteRequest, opts ...grpc.CallOption) (*SetThreatProtectionLiteResponse, error)
	SetDefaults(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	SetDNS(ctx context.Context, in *SetDNSRequest, opts ...grpc.CallOption) (*SetDNSResponse, error)
	SetFirewall(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetFirewallMark(ctx context.Context, in *SetUint32Request, opts ...grpc.CallOption) (*Payload, error)
	SetRouting(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetAnalytics(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetKillSwitch(ctx context.Context, in *SetKillSwitchRequest, opts ...grpc.CallOption) (*Payload, error)
	SetNotify(ctx context.Context, in *SetNotifyRequest, opts ...grpc.CallOption) (*Payload, error)
	SetTray(ctx context.Context, in *SetTrayRequest, opts ...grpc.CallOption) (*Payload, error)
	SetObfuscate(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetProtocol(ctx context.Context, in *SetProtocolRequest, opts ...grpc.CallOption) (*SetProtocolResponse, error)
	SetTechnology(ctx context.Context, in *SetTechnologyRequest, opts ...grpc.CallOption) (*Payload, error)
	SetLANDiscovery(ctx context.Context, in *SetLANDiscoveryRequest, opts ...grpc.CallOption) (*SetLANDiscoveryResponse, error)
	SetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error)
	UnsetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error)
	UnsetAllAllowlist(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	Settings(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SettingsResponse, error)
	SettingsProtocols(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	SettingsTechnologies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error)
	SetIpv6(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	ClaimOnlinePurchase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ClaimOnlinePurchaseResponse, error)
	SetVirtualLocation(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SubscribeToStateChanges(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AppState], error)
	GetServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServersResponse, error)
	SetPostQuantum(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	IsNordWhisperEnabled(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NordWhisperEnabled, error)
	GetDaemonApiVersion(ctx context.Context, in *GetDaemonApiVersionRequest, opts ...grpc.CallOption) (*GetDaemonApiVersionResponse, error)
}

type daemonClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonClient(cc grpc.ClientConnInterface) DaemonClient {
	return &daemonClient{cc}
}

func (c *daemonClient) AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AccountResponse)
	err := c.cc.Invoke(ctx, Daemon_AccountInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) TokenInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TokenInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenInfoResponse)
	err := c.cc.Invoke(ctx, Daemon_TokenInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Cities(ctx context.Context, in *CitiesRequest, opts ...grpc.CallOption) (*ServerGroupsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerGroupsList)
	err := c.cc.Invoke(ctx, Daemon_Cities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Payload], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[0], Daemon_Connect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConnectRequest, Payload]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Daemon_ConnectClient = grpc.ServerStreamingClient[Payload]

func (c *daemonClient) ConnectCancel(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_ConnectCancel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Countries(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerGroupsList)
	err := c.cc.Invoke(ctx, Daemon_Countries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Disconnect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Payload], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[1], Daemon_Disconnect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, Payload]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Daemon_DisconnectClient = grpc.ServerStreamingClient[Payload]

func (c *daemonClient) Groups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerGroupsList)
	err := c.cc.Invoke(ctx, Daemon_Groups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) IsLoggedIn(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bool, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bool)
	err := c.cc.Invoke(ctx, Daemon_IsLoggedIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) LoginWithToken(ctx context.Context, in *LoginWithTokenRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, Daemon_LoginWithToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) LoginOAuth2(ctx context.Context, in *LoginOAuth2Request, opts ...grpc.CallOption) (*LoginOAuth2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginOAuth2Response)
	err := c.cc.Invoke(ctx, Daemon_LoginOAuth2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) LoginOAuth2Callback(ctx context.Context, in *LoginOAuth2CallbackRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Daemon_LoginOAuth2Callback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, Daemon_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) RateConnection(ctx context.Context, in *RateRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_RateConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetAutoConnect(ctx context.Context, in *SetAutoconnectRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetAutoConnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetThreatProtectionLite(ctx context.Context, in *SetThreatProtectionLiteRequest, opts ...grpc.CallOption) (*SetThreatProtectionLiteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetThreatProtectionLiteResponse)
	err := c.cc.Invoke(ctx, Daemon_SetThreatProtectionLite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetDefaults(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetDefaults_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetDNS(ctx context.Context, in *SetDNSRequest, opts ...grpc.CallOption) (*SetDNSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDNSResponse)
	err := c.cc.Invoke(ctx, Daemon_SetDNS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetFirewall(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetFirewall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetFirewallMark(ctx context.Context, in *SetUint32Request, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetFirewallMark_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetRouting(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetRouting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetAnalytics(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetKillSwitch(ctx context.Context, in *SetKillSwitchRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetKillSwitch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetNotify(ctx context.Context, in *SetNotifyRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetNotify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetTray(ctx context.Context, in *SetTrayRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetTray_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetObfuscate(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetObfuscate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetProtocol(ctx context.Context, in *SetProtocolRequest, opts ...grpc.CallOption) (*SetProtocolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetProtocolResponse)
	err := c.cc.Invoke(ctx, Daemon_SetProtocol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetTechnology(ctx context.Context, in *SetTechnologyRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetTechnology_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetLANDiscovery(ctx context.Context, in *SetLANDiscoveryRequest, opts ...grpc.CallOption) (*SetLANDiscoveryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLANDiscoveryResponse)
	err := c.cc.Invoke(ctx, Daemon_SetLANDiscovery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetAllowlist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) UnsetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_UnsetAllowlist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) UnsetAllAllowlist(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_UnsetAllAllowlist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Settings(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, Daemon_Settings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SettingsProtocols(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SettingsProtocols_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SettingsTechnologies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SettingsTechnologies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, Daemon_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetIpv6(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetIpv6_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ClaimOnlinePurchase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ClaimOnlinePurchaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClaimOnlinePurchaseResponse)
	err := c.cc.Invoke(ctx, Daemon_ClaimOnlinePurchase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetVirtualLocation(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetVirtualLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SubscribeToStateChanges(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AppState], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[2], Daemon_SubscribeToStateChanges_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, AppState]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Daemon_SubscribeToStateChangesClient = grpc.ServerStreamingClient[AppState]

func (c *daemonClient) GetServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServersResponse)
	err := c.cc.Invoke(ctx, Daemon_GetServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetPostQuantum(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payload)
	err := c.cc.Invoke(ctx, Daemon_SetPostQuantum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) IsNordWhisperEnabled(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NordWhisperEnabled, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NordWhisperEnabled)
	err := c.cc.Invoke(ctx, Daemon_IsNordWhisperEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetDaemonApiVersion(ctx context.Context, in *GetDaemonApiVersionRequest, opts ...grpc.CallOption) (*GetDaemonApiVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDaemonApiVersionResponse)
	err := c.cc.Invoke(ctx, Daemon_GetDaemonApiVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonServer is the server API for Daemon service.
// All implementations must embed UnimplementedDaemonServer
// for forward compatibility.
type DaemonServer interface {
	AccountInfo(context.Context, *Empty) (*AccountResponse, error)
	TokenInfo(context.Context, *Empty) (*TokenInfoResponse, error)
	Cities(context.Context, *CitiesRequest) (*ServerGroupsList, error)
	Connect(*ConnectRequest, grpc.ServerStreamingServer[Payload]) error
	ConnectCancel(context.Context, *Empty) (*Payload, error)
	Countries(context.Context, *Empty) (*ServerGroupsList, error)
	Disconnect(*Empty, grpc.ServerStreamingServer[Payload]) error
	Groups(context.Context, *Empty) (*ServerGroupsList, error)
	IsLoggedIn(context.Context, *Empty) (*Bool, error)
	LoginWithToken(context.Context, *LoginWithTokenRequest) (*LoginResponse, error)
	LoginOAuth2(context.Context, *LoginOAuth2Request) (*LoginOAuth2Response, error)
	LoginOAuth2Callback(context.Context, *LoginOAuth2CallbackRequest) (*Empty, error)
	Logout(context.Context, *LogoutRequest) (*Payload, error)
	Ping(context.Context, *Empty) (*PingResponse, error)
	RateConnection(context.Context, *RateRequest) (*Payload, error)
	SetAutoConnect(context.Context, *SetAutoconnectRequest) (*Payload, error)
	SetThreatProtectionLite(context.Context, *SetThreatProtectionLiteRequest) (*SetThreatProtectionLiteResponse, error)
	SetDefaults(context.Context, *Empty) (*Payload, error)
	SetDNS(context.Context, *SetDNSRequest) (*SetDNSResponse, error)
	SetFirewall(context.Context, *SetGenericRequest) (*Payload, error)
	SetFirewallMark(context.Context, *SetUint32Request) (*Payload, error)
	SetRouting(context.Context, *SetGenericRequest) (*Payload, error)
	SetAnalytics(context.Context, *SetGenericRequest) (*Payload, error)
	SetKillSwitch(context.Context, *SetKillSwitchRequest) (*Payload, error)
	SetNotify(context.Context, *SetNotifyRequest) (*Payload, error)
	SetTray(context.Context, *SetTrayRequest) (*Payload, error)
	SetObfuscate(context.Context, *SetGenericRequest) (*Payload, error)
	SetProtocol(context.Context, *SetProtocolRequest) (*SetProtocolResponse, error)
	SetTechnology(context.Context, *SetTechnologyRequest) (*Payload, error)
	SetLANDiscovery(context.Context, *SetLANDiscoveryRequest) (*SetLANDiscoveryResponse, error)
	SetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error)
	UnsetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error)
	UnsetAllAllowlist(context.Context, *Empty) (*Payload, error)
	Settings(context.Context, *Empty) (*SettingsResponse, error)
	SettingsProtocols(context.Context, *Empty) (*Payload, error)
	SettingsTechnologies(context.Context, *Empty) (*Payload, error)
	Status(context.Context, *Empty) (*StatusResponse, error)
	SetIpv6(context.Context, *SetGenericRequest) (*Payload, error)
	ClaimOnlinePurchase(context.Context, *Empty) (*ClaimOnlinePurchaseResponse, error)
	SetVirtualLocation(context.Context, *SetGenericRequest) (*Payload, error)
	SubscribeToStateChanges(*Empty, grpc.ServerStreamingServer[AppState]) error
	GetServers(context.Context, *Empty) (*ServersResponse, error)
	SetPostQuantum(context.Context, *SetGenericRequest) (*Payload, error)
	IsNordWhisperEnabled(context.Context, *Empty) (*NordWhisperEnabled, error)
	GetDaemonApiVersion(context.Context, *GetDaemonApiVersionRequest) (*GetDaemonApiVersionResponse, error)
	mustEmbedUnimplementedDaemonServer()
}

// UnimplementedDaemonServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDaemonServer struct{}

func (UnimplementedDaemonServer) AccountInfo(context.Context, *Empty) (*AccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountInfo not implemented")
}
func (UnimplementedDaemonServer) TokenInfo(context.Context, *Empty) (*TokenInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenInfo not implemented")
}
func (UnimplementedDaemonServer) Cities(context.Context, *CitiesRequest) (*ServerGroupsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cities not implemented")
}
func (UnimplementedDaemonServer) Connect(*ConnectRequest, grpc.ServerStreamingServer[Payload]) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedDaemonServer) ConnectCancel(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectCancel not implemented")
}
func (UnimplementedDaemonServer) Countries(context.Context, *Empty) (*ServerGroupsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Countries not implemented")
}
func (UnimplementedDaemonServer) Disconnect(*Empty, grpc.ServerStreamingServer[Payload]) error {
	return status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedDaemonServer) Groups(context.Context, *Empty) (*ServerGroupsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Groups not implemented")
}
func (UnimplementedDaemonServer) IsLoggedIn(context.Context, *Empty) (*Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLoggedIn not implemented")
}
func (UnimplementedDaemonServer) LoginWithToken(context.Context, *LoginWithTokenRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginWithToken not implemented")
}
func (UnimplementedDaemonServer) LoginOAuth2(context.Context, *LoginOAuth2Request) (*LoginOAuth2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginOAuth2 not implemented")
}
func (UnimplementedDaemonServer) LoginOAuth2Callback(context.Context, *LoginOAuth2CallbackRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginOAuth2Callback not implemented")
}
func (UnimplementedDaemonServer) Logout(context.Context, *LogoutRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedDaemonServer) Ping(context.Context, *Empty) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedDaemonServer) RateConnection(context.Context, *RateRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateConnection not implemented")
}
func (UnimplementedDaemonServer) SetAutoConnect(context.Context, *SetAutoconnectRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAutoConnect not implemented")
}
func (UnimplementedDaemonServer) SetThreatProtectionLite(context.Context, *SetThreatProtectionLiteRequest) (*SetThreatProtectionLiteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetThreatProtectionLite not implemented")
}
func (UnimplementedDaemonServer) SetDefaults(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaults not implemented")
}
func (UnimplementedDaemonServer) SetDNS(context.Context, *SetDNSRequest) (*SetDNSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDNS not implemented")
}
func (UnimplementedDaemonServer) SetFirewall(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFirewall not implemented")
}
func (UnimplementedDaemonServer) SetFirewallMark(context.Context, *SetUint32Request) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFirewallMark not implemented")
}
func (UnimplementedDaemonServer) SetRouting(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRouting not implemented")
}
func (UnimplementedDaemonServer) SetAnalytics(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAnalytics not implemented")
}
func (UnimplementedDaemonServer) SetKillSwitch(context.Context, *SetKillSwitchRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKillSwitch not implemented")
}
func (UnimplementedDaemonServer) SetNotify(context.Context, *SetNotifyRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNotify not implemented")
}
func (UnimplementedDaemonServer) SetTray(context.Context, *SetTrayRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTray not implemented")
}
func (UnimplementedDaemonServer) SetObfuscate(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetObfuscate not implemented")
}
func (UnimplementedDaemonServer) SetProtocol(context.Context, *SetProtocolRequest) (*SetProtocolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProtocol not implemented")
}
func (UnimplementedDaemonServer) SetTechnology(context.Context, *SetTechnologyRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTechnology not implemented")
}
func (UnimplementedDaemonServer) SetLANDiscovery(context.Context, *SetLANDiscoveryRequest) (*SetLANDiscoveryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLANDiscovery not implemented")
}
func (UnimplementedDaemonServer) SetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAllowlist not implemented")
}
func (UnimplementedDaemonServer) UnsetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsetAllowlist not implemented")
}
func (UnimplementedDaemonServer) UnsetAllAllowlist(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsetAllAllowlist not implemented")
}
func (UnimplementedDaemonServer) Settings(context.Context, *Empty) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Settings not implemented")
}
func (UnimplementedDaemonServer) SettingsProtocols(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettingsProtocols not implemented")
}
func (UnimplementedDaemonServer) SettingsTechnologies(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettingsTechnologies not implemented")
}
func (UnimplementedDaemonServer) Status(context.Context, *Empty) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedDaemonServer) SetIpv6(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIpv6 not implemented")
}
func (UnimplementedDaemonServer) ClaimOnlinePurchase(context.Context, *Empty) (*ClaimOnlinePurchaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimOnlinePurchase not implemented")
}
func (UnimplementedDaemonServer) SetVirtualLocation(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVirtualLocation not implemented")
}
func (UnimplementedDaemonServer) SubscribeToStateChanges(*Empty, grpc.ServerStreamingServer[AppState]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToStateChanges not implemented")
}
func (UnimplementedDaemonServer) GetServers(context.Context, *Empty) (*ServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServers not implemented")
}
func (UnimplementedDaemonServer) SetPostQuantum(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPostQuantum not implemented")
}
func (UnimplementedDaemonServer) IsNordWhisperEnabled(context.Context, *Empty) (*NordWhisperEnabled, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsNordWhisperEnabled not implemented")
}
func (UnimplementedDaemonServer) GetDaemonApiVersion(context.Context, *GetDaemonApiVersionRequest) (*GetDaemonApiVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDaemonApiVersion not implemented")
}
func (UnimplementedDaemonServer) mustEmbedUnimplementedDaemonServer() {}
func (UnimplementedDaemonServer) testEmbeddedByValue()                {}

// UnsafeDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonServer will
// result in compilation errors.
type UnsafeDaemonServer interface {
	mustEmbedUnimplementedDaemonServer()
}

func RegisterDaemonServer(s grpc.ServiceRegistrar, srv DaemonServer) {
	// If the following call pancis, it indicates UnimplementedDaemonServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Daemon_ServiceDesc, srv)
}

func _Daemon_AccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).AccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_AccountInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).AccountInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_TokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).TokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_TokenInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).TokenInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Cities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Cities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_Cities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Cities(ctx, req.(*CitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConnectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).Connect(m, &grpc.GenericServerStream[ConnectRequest, Payload]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Daemon_ConnectServer = grpc.ServerStreamingServer[Payload]

func _Daemon_ConnectCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ConnectCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_ConnectCancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ConnectCancel(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Countries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Countries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_Countries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Countries(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Disconnect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).Disconnect(m, &grpc.GenericServerStream[Empty, Payload]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Daemon_DisconnectServer = grpc.ServerStreamingServer[Payload]

func _Daemon_Groups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Groups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_Groups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Groups(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_IsLoggedIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).IsLoggedIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_IsLoggedIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).IsLoggedIn(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_LoginWithToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginWithTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginWithToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_LoginWithToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginWithToken(ctx, req.(*LoginWithTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_LoginOAuth2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginOAuth2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginOAuth2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_LoginOAuth2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginOAuth2(ctx, req.(*LoginOAuth2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_LoginOAuth2Callback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginOAuth2CallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginOAuth2Callback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_LoginOAuth2Callback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginOAuth2Callback(ctx, req.(*LoginOAuth2CallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_RateConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).RateConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_RateConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).RateConnection(ctx, req.(*RateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetAutoConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutoconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetAutoConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetAutoConnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetAutoConnect(ctx, req.(*SetAutoconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetThreatProtectionLite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetThreatProtectionLiteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetThreatProtectionLite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetThreatProtectionLite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetThreatProtectionLite(ctx, req.(*SetThreatProtectionLiteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetDefaults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetDefaults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetDefaults_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetDefaults(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetDNS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetDNS(ctx, req.(*SetDNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetFirewall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetFirewall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetFirewall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetFirewall(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetFirewallMark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUint32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetFirewallMark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetFirewallMark_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetFirewallMark(ctx, req.(*SetUint32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetRouting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetRouting(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetAnalytics(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetKillSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKillSwitchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetKillSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetKillSwitch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetKillSwitch(ctx, req.(*SetKillSwitchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNotifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetNotify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetNotify(ctx, req.(*SetNotifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetTray_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTrayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetTray(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetTray_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetTray(ctx, req.(*SetTrayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetObfuscate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetObfuscate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetObfuscate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetObfuscate(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetProtocol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProtocolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetProtocol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetProtocol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetProtocol(ctx, req.(*SetProtocolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetTechnology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTechnologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetTechnology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetTechnology_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetTechnology(ctx, req.(*SetTechnologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetLANDiscovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLANDiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetLANDiscovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetLANDiscovery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetLANDiscovery(ctx, req.(*SetLANDiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAllowlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetAllowlist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetAllowlist(ctx, req.(*SetAllowlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_UnsetAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAllowlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).UnsetAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_UnsetAllowlist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).UnsetAllowlist(ctx, req.(*SetAllowlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_UnsetAllAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).UnsetAllAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_UnsetAllAllowlist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).UnsetAllAllowlist(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Settings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Settings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_Settings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Settings(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SettingsProtocols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SettingsProtocols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SettingsProtocols_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SettingsProtocols(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SettingsTechnologies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SettingsTechnologies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SettingsTechnologies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SettingsTechnologies(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Status(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetIpv6_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetIpv6(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetIpv6_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetIpv6(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ClaimOnlinePurchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ClaimOnlinePurchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_ClaimOnlinePurchase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ClaimOnlinePurchase(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetVirtualLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetVirtualLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetVirtualLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetVirtualLocation(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SubscribeToStateChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).SubscribeToStateChanges(m, &grpc.GenericServerStream[Empty, AppState]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Daemon_SubscribeToStateChangesServer = grpc.ServerStreamingServer[AppState]

func _Daemon_GetServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_GetServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetPostQuantum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetPostQuantum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_SetPostQuantum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetPostQuantum(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_IsNordWhisperEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).IsNordWhisperEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_IsNordWhisperEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).IsNordWhisperEnabled(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetDaemonApiVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDaemonApiVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetDaemonApiVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Daemon_GetDaemonApiVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetDaemonApiVersion(ctx, req.(*GetDaemonApiVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Daemon_ServiceDesc is the grpc.ServiceDesc for Daemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Daemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Daemon",
	HandlerType: (*DaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AccountInfo",
			Handler:    _Daemon_AccountInfo_Handler,
		},
		{
			MethodName: "TokenInfo",
			Handler:    _Daemon_TokenInfo_Handler,
		},
		{
			MethodName: "Cities",
			Handler:    _Daemon_Cities_Handler,
		},
		{
			MethodName: "ConnectCancel",
			Handler:    _Daemon_ConnectCancel_Handler,
		},
		{
			MethodName: "Countries",
			Handler:    _Daemon_Countries_Handler,
		},
		{
			MethodName: "Groups",
			Handler:    _Daemon_Groups_Handler,
		},
		{
			MethodName: "IsLoggedIn",
			Handler:    _Daemon_IsLoggedIn_Handler,
		},
		{
			MethodName: "LoginWithToken",
			Handler:    _Daemon_LoginWithToken_Handler,
		},
		{
			MethodName: "LoginOAuth2",
			Handler:    _Daemon_LoginOAuth2_Handler,
		},
		{
			MethodName: "LoginOAuth2Callback",
			Handler:    _Daemon_LoginOAuth2Callback_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Daemon_Logout_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Daemon_Ping_Handler,
		},
		{
			MethodName: "RateConnection",
			Handler:    _Daemon_RateConnection_Handler,
		},
		{
			MethodName: "SetAutoConnect",
			Handler:    _Daemon_SetAutoConnect_Handler,
		},
		{
			MethodName: "SetThreatProtectionLite",
			Handler:    _Daemon_SetThreatProtectionLite_Handler,
		},
		{
			MethodName: "SetDefaults",
			Handler:    _Daemon_SetDefaults_Handler,
		},
		{
			MethodName: "SetDNS",
			Handler:    _Daemon_SetDNS_Handler,
		},
		{
			MethodName: "SetFirewall",
			Handler:    _Daemon_SetFirewall_Handler,
		},
		{
			MethodName: "SetFirewallMark",
			Handler:    _Daemon_SetFirewallMark_Handler,
		},
		{
			MethodName: "SetRouting",
			Handler:    _Daemon_SetRouting_Handler,
		},
		{
			MethodName: "SetAnalytics",
			Handler:    _Daemon_SetAnalytics_Handler,
		},
		{
			MethodName: "SetKillSwitch",
			Handler:    _Daemon_SetKillSwitch_Handler,
		},
		{
			MethodName: "SetNotify",
			Handler:    _Daemon_SetNotify_Handler,
		},
		{
			MethodName: "SetTray",
			Handler:    _Daemon_SetTray_Handler,
		},
		{
			MethodName: "SetObfuscate",
			Handler:    _Daemon_SetObfuscate_Handler,
		},
		{
			MethodName: "SetProtocol",
			Handler:    _Daemon_SetProtocol_Handler,
		},
		{
			MethodName: "SetTechnology",
			Handler:    _Daemon_SetTechnology_Handler,
		},
		{
			MethodName: "SetLANDiscovery",
			Handler:    _Daemon_SetLANDiscovery_Handler,
		},
		{
			MethodName: "SetAllowlist",
			Handler:    _Daemon_SetAllowlist_Handler,
		},
		{
			MethodName: "UnsetAllowlist",
			Handler:    _Daemon_UnsetAllowlist_Handler,
		},
		{
			MethodName: "UnsetAllAllowlist",
			Handler:    _Daemon_UnsetAllAllowlist_Handler,
		},
		{
			MethodName: "Settings",
			Handler:    _Daemon_Settings_Handler,
		},
		{
			MethodName: "SettingsProtocols",
			Handler:    _Daemon_SettingsProtocols_Handler,
		},
		{
			MethodName: "SettingsTechnologies",
			Handler:    _Daemon_SettingsTechnologies_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Daemon_Status_Handler,
		},
		{
			MethodName: "SetIpv6",
			Handler:    _Daemon_SetIpv6_Handler,
		},
		{
			MethodName: "ClaimOnlinePurchase",
			Handler:    _Daemon_ClaimOnlinePurchase_Handler,
		},
		{
			MethodName: "SetVirtualLocation",
			Handler:    _Daemon_SetVirtualLocation_Handler,
		},
		{
			MethodName: "GetServers",
			Handler:    _Daemon_GetServers_Handler,
		},
		{
			MethodName: "SetPostQuantum",
			Handler:    _Daemon_SetPostQuantum_Handler,
		},
		{
			MethodName: "IsNordWhisperEnabled",
			Handler:    _Daemon_IsNordWhisperEnabled_Handler,
		},
		{
			MethodName: "GetDaemonApiVersion",
			Handler:    _Daemon_GetDaemonApiVersion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _Daemon_Connect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Disconnect",
			Handler:       _Daemon_Disconnect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToStateChanges",
			Handler:       _Daemon_SubscribeToStateChanges_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protobuf/daemon/service.proto",
}
