// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DaemonClient is the client API for Daemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DaemonClient interface {
	AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountResponse, error)
	TokenInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TokenInfoResponse, error)
	Cities(ctx context.Context, in *CitiesRequest, opts ...grpc.CallOption) (*ServerGroupsList, error)
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (Daemon_ConnectClient, error)
	Countries(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error)
	Disconnect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_DisconnectClient, error)
	Groups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error)
	IsLoggedIn(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bool, error)
	LoginWithToken(ctx context.Context, in *LoginWithTokenRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	LoginOAuth2(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_LoginOAuth2Client, error)
	LoginOAuth2Callback(ctx context.Context, in *String, opts ...grpc.CallOption) (*Empty, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Payload, error)
	Plans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PlansResponse, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResponse, error)
	RateConnection(ctx context.Context, in *RateRequest, opts ...grpc.CallOption) (*Payload, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*Payload, error)
	SetAutoConnect(ctx context.Context, in *SetAutoconnectRequest, opts ...grpc.CallOption) (*Payload, error)
	SetThreatProtectionLite(ctx context.Context, in *SetThreatProtectionLiteRequest, opts ...grpc.CallOption) (*SetThreatProtectionLiteResponse, error)
	SetDefaults(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	SetDNS(ctx context.Context, in *SetDNSRequest, opts ...grpc.CallOption) (*SetDNSResponse, error)
	SetFirewall(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetFirewallMark(ctx context.Context, in *SetUint32Request, opts ...grpc.CallOption) (*Payload, error)
	SetRouting(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetAnalytics(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetKillSwitch(ctx context.Context, in *SetKillSwitchRequest, opts ...grpc.CallOption) (*Payload, error)
	SetNotify(ctx context.Context, in *SetNotifyRequest, opts ...grpc.CallOption) (*Payload, error)
	SetTray(ctx context.Context, in *SetTrayRequest, opts ...grpc.CallOption) (*Payload, error)
	SetObfuscate(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetProtocol(ctx context.Context, in *SetProtocolRequest, opts ...grpc.CallOption) (*SetProtocolResponse, error)
	SetTechnology(ctx context.Context, in *SetTechnologyRequest, opts ...grpc.CallOption) (*Payload, error)
	SetLANDiscovery(ctx context.Context, in *SetLANDiscoveryRequest, opts ...grpc.CallOption) (*SetLANDiscoveryResponse, error)
	SetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error)
	UnsetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error)
	UnsetAllAllowlist(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	Settings(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SettingsResponse, error)
	SettingsProtocols(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	SettingsTechnologies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error)
	Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error)
	SetIpv6(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	ClaimOnlinePurchase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ClaimOnlinePurchaseResponse, error)
	SetVirtualLocation(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SubscribeToStateChanges(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_SubscribeToStateChangesClient, error)
	GetServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServersResponse, error)
	SetPostQuantum(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
}

type daemonClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonClient(cc grpc.ClientConnInterface) DaemonClient {
	return &daemonClient{cc}
}

func (c *daemonClient) AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AccountResponse, error) {
	out := new(AccountResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/AccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) TokenInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TokenInfoResponse, error) {
	out := new(TokenInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/TokenInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Cities(ctx context.Context, in *CitiesRequest, opts ...grpc.CallOption) (*ServerGroupsList, error) {
	out := new(ServerGroupsList)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Cities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (Daemon_ConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[0], "/pb.Daemon/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonConnectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_ConnectClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type daemonConnectClient struct {
	grpc.ClientStream
}

func (x *daemonConnectClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) Countries(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error) {
	out := new(ServerGroupsList)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Countries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Disconnect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_DisconnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[1], "/pb.Daemon/Disconnect", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonDisconnectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_DisconnectClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type daemonDisconnectClient struct {
	grpc.ClientStream
}

func (x *daemonDisconnectClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) Groups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServerGroupsList, error) {
	out := new(ServerGroupsList)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Groups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) IsLoggedIn(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := c.cc.Invoke(ctx, "/pb.Daemon/IsLoggedIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) LoginWithToken(ctx context.Context, in *LoginWithTokenRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/LoginWithToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) LoginOAuth2(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_LoginOAuth2Client, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[2], "/pb.Daemon/LoginOAuth2", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonLoginOAuth2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_LoginOAuth2Client interface {
	Recv() (*String, error)
	grpc.ClientStream
}

type daemonLoginOAuth2Client struct {
	grpc.ClientStream
}

func (x *daemonLoginOAuth2Client) Recv() (*String, error) {
	m := new(String)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) LoginOAuth2Callback(ctx context.Context, in *String, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/pb.Daemon/LoginOAuth2Callback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Plans(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PlansResponse, error) {
	out := new(PlansResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Plans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) RateConnection(ctx context.Context, in *RateRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/RateConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetAutoConnect(ctx context.Context, in *SetAutoconnectRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetAutoConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetThreatProtectionLite(ctx context.Context, in *SetThreatProtectionLiteRequest, opts ...grpc.CallOption) (*SetThreatProtectionLiteResponse, error) {
	out := new(SetThreatProtectionLiteResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetThreatProtectionLite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetDefaults(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetDefaults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetDNS(ctx context.Context, in *SetDNSRequest, opts ...grpc.CallOption) (*SetDNSResponse, error) {
	out := new(SetDNSResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetDNS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetFirewall(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetFirewall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetFirewallMark(ctx context.Context, in *SetUint32Request, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetFirewallMark", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetRouting(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetRouting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetAnalytics(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetAnalytics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetKillSwitch(ctx context.Context, in *SetKillSwitchRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetKillSwitch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetNotify(ctx context.Context, in *SetNotifyRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetNotify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetTray(ctx context.Context, in *SetTrayRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetTray", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetObfuscate(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetObfuscate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetProtocol(ctx context.Context, in *SetProtocolRequest, opts ...grpc.CallOption) (*SetProtocolResponse, error) {
	out := new(SetProtocolResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetProtocol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetTechnology(ctx context.Context, in *SetTechnologyRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetTechnology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetLANDiscovery(ctx context.Context, in *SetLANDiscoveryRequest, opts ...grpc.CallOption) (*SetLANDiscoveryResponse, error) {
	out := new(SetLANDiscoveryResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetLANDiscovery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetAllowlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) UnsetAllowlist(ctx context.Context, in *SetAllowlistRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/UnsetAllowlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) UnsetAllAllowlist(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/UnsetAllAllowlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Settings(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Settings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SettingsProtocols(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SettingsProtocols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SettingsTechnologies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SettingsTechnologies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Status(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetIpv6(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetIpv6", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ClaimOnlinePurchase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ClaimOnlinePurchaseResponse, error) {
	out := new(ClaimOnlinePurchaseResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/ClaimOnlinePurchase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetVirtualLocation(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetVirtualLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SubscribeToStateChanges(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_SubscribeToStateChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[3], "/pb.Daemon/SubscribeToStateChanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonSubscribeToStateChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_SubscribeToStateChangesClient interface {
	Recv() (*AppState, error)
	grpc.ClientStream
}

type daemonSubscribeToStateChangesClient struct {
	grpc.ClientStream
}

func (x *daemonSubscribeToStateChangesClient) Recv() (*AppState, error) {
	m := new(AppState)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) GetServers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServersResponse, error) {
	out := new(ServersResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/GetServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetPostQuantum(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetPostQuantum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonServer is the server API for Daemon service.
// All implementations must embed UnimplementedDaemonServer
// for forward compatibility
type DaemonServer interface {
	AccountInfo(context.Context, *Empty) (*AccountResponse, error)
	TokenInfo(context.Context, *Empty) (*TokenInfoResponse, error)
	Cities(context.Context, *CitiesRequest) (*ServerGroupsList, error)
	Connect(*ConnectRequest, Daemon_ConnectServer) error
	Countries(context.Context, *Empty) (*ServerGroupsList, error)
	Disconnect(*Empty, Daemon_DisconnectServer) error
	Groups(context.Context, *Empty) (*ServerGroupsList, error)
	IsLoggedIn(context.Context, *Empty) (*Bool, error)
	LoginWithToken(context.Context, *LoginWithTokenRequest) (*LoginResponse, error)
	LoginOAuth2(*Empty, Daemon_LoginOAuth2Server) error
	LoginOAuth2Callback(context.Context, *String) (*Empty, error)
	Logout(context.Context, *LogoutRequest) (*Payload, error)
	Plans(context.Context, *Empty) (*PlansResponse, error)
	Ping(context.Context, *Empty) (*PingResponse, error)
	RateConnection(context.Context, *RateRequest) (*Payload, error)
	Register(context.Context, *RegisterRequest) (*Payload, error)
	SetAutoConnect(context.Context, *SetAutoconnectRequest) (*Payload, error)
	SetThreatProtectionLite(context.Context, *SetThreatProtectionLiteRequest) (*SetThreatProtectionLiteResponse, error)
	SetDefaults(context.Context, *Empty) (*Payload, error)
	SetDNS(context.Context, *SetDNSRequest) (*SetDNSResponse, error)
	SetFirewall(context.Context, *SetGenericRequest) (*Payload, error)
	SetFirewallMark(context.Context, *SetUint32Request) (*Payload, error)
	SetRouting(context.Context, *SetGenericRequest) (*Payload, error)
	SetAnalytics(context.Context, *SetGenericRequest) (*Payload, error)
	SetKillSwitch(context.Context, *SetKillSwitchRequest) (*Payload, error)
	SetNotify(context.Context, *SetNotifyRequest) (*Payload, error)
	SetTray(context.Context, *SetTrayRequest) (*Payload, error)
	SetObfuscate(context.Context, *SetGenericRequest) (*Payload, error)
	SetProtocol(context.Context, *SetProtocolRequest) (*SetProtocolResponse, error)
	SetTechnology(context.Context, *SetTechnologyRequest) (*Payload, error)
	SetLANDiscovery(context.Context, *SetLANDiscoveryRequest) (*SetLANDiscoveryResponse, error)
	SetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error)
	UnsetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error)
	UnsetAllAllowlist(context.Context, *Empty) (*Payload, error)
	Settings(context.Context, *Empty) (*SettingsResponse, error)
	SettingsProtocols(context.Context, *Empty) (*Payload, error)
	SettingsTechnologies(context.Context, *Empty) (*Payload, error)
	Status(context.Context, *Empty) (*StatusResponse, error)
	SetIpv6(context.Context, *SetGenericRequest) (*Payload, error)
	ClaimOnlinePurchase(context.Context, *Empty) (*ClaimOnlinePurchaseResponse, error)
	SetVirtualLocation(context.Context, *SetGenericRequest) (*Payload, error)
	SubscribeToStateChanges(*Empty, Daemon_SubscribeToStateChangesServer) error
	GetServers(context.Context, *Empty) (*ServersResponse, error)
	SetPostQuantum(context.Context, *SetGenericRequest) (*Payload, error)
	mustEmbedUnimplementedDaemonServer()
}

// UnimplementedDaemonServer must be embedded to have forward compatible implementations.
type UnimplementedDaemonServer struct {
}

func (UnimplementedDaemonServer) AccountInfo(context.Context, *Empty) (*AccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountInfo not implemented")
}
func (UnimplementedDaemonServer) TokenInfo(context.Context, *Empty) (*TokenInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenInfo not implemented")
}
func (UnimplementedDaemonServer) Cities(context.Context, *CitiesRequest) (*ServerGroupsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cities not implemented")
}
func (UnimplementedDaemonServer) Connect(*ConnectRequest, Daemon_ConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedDaemonServer) Countries(context.Context, *Empty) (*ServerGroupsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Countries not implemented")
}
func (UnimplementedDaemonServer) Disconnect(*Empty, Daemon_DisconnectServer) error {
	return status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedDaemonServer) Groups(context.Context, *Empty) (*ServerGroupsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Groups not implemented")
}
func (UnimplementedDaemonServer) IsLoggedIn(context.Context, *Empty) (*Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLoggedIn not implemented")
}
func (UnimplementedDaemonServer) LoginWithToken(context.Context, *LoginWithTokenRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginWithToken not implemented")
}
func (UnimplementedDaemonServer) LoginOAuth2(*Empty, Daemon_LoginOAuth2Server) error {
	return status.Errorf(codes.Unimplemented, "method LoginOAuth2 not implemented")
}
func (UnimplementedDaemonServer) LoginOAuth2Callback(context.Context, *String) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginOAuth2Callback not implemented")
}
func (UnimplementedDaemonServer) Logout(context.Context, *LogoutRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedDaemonServer) Plans(context.Context, *Empty) (*PlansResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Plans not implemented")
}
func (UnimplementedDaemonServer) Ping(context.Context, *Empty) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedDaemonServer) RateConnection(context.Context, *RateRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateConnection not implemented")
}
func (UnimplementedDaemonServer) Register(context.Context, *RegisterRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedDaemonServer) SetAutoConnect(context.Context, *SetAutoconnectRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAutoConnect not implemented")
}
func (UnimplementedDaemonServer) SetThreatProtectionLite(context.Context, *SetThreatProtectionLiteRequest) (*SetThreatProtectionLiteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetThreatProtectionLite not implemented")
}
func (UnimplementedDaemonServer) SetDefaults(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaults not implemented")
}
func (UnimplementedDaemonServer) SetDNS(context.Context, *SetDNSRequest) (*SetDNSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDNS not implemented")
}
func (UnimplementedDaemonServer) SetFirewall(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFirewall not implemented")
}
func (UnimplementedDaemonServer) SetFirewallMark(context.Context, *SetUint32Request) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFirewallMark not implemented")
}
func (UnimplementedDaemonServer) SetRouting(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRouting not implemented")
}
func (UnimplementedDaemonServer) SetAnalytics(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAnalytics not implemented")
}
func (UnimplementedDaemonServer) SetKillSwitch(context.Context, *SetKillSwitchRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKillSwitch not implemented")
}
func (UnimplementedDaemonServer) SetNotify(context.Context, *SetNotifyRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNotify not implemented")
}
func (UnimplementedDaemonServer) SetTray(context.Context, *SetTrayRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTray not implemented")
}
func (UnimplementedDaemonServer) SetObfuscate(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetObfuscate not implemented")
}
func (UnimplementedDaemonServer) SetProtocol(context.Context, *SetProtocolRequest) (*SetProtocolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProtocol not implemented")
}
func (UnimplementedDaemonServer) SetTechnology(context.Context, *SetTechnologyRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTechnology not implemented")
}
func (UnimplementedDaemonServer) SetLANDiscovery(context.Context, *SetLANDiscoveryRequest) (*SetLANDiscoveryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLANDiscovery not implemented")
}
func (UnimplementedDaemonServer) SetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAllowlist not implemented")
}
func (UnimplementedDaemonServer) UnsetAllowlist(context.Context, *SetAllowlistRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsetAllowlist not implemented")
}
func (UnimplementedDaemonServer) UnsetAllAllowlist(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsetAllAllowlist not implemented")
}
func (UnimplementedDaemonServer) Settings(context.Context, *Empty) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Settings not implemented")
}
func (UnimplementedDaemonServer) SettingsProtocols(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettingsProtocols not implemented")
}
func (UnimplementedDaemonServer) SettingsTechnologies(context.Context, *Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettingsTechnologies not implemented")
}
func (UnimplementedDaemonServer) Status(context.Context, *Empty) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedDaemonServer) SetIpv6(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIpv6 not implemented")
}
func (UnimplementedDaemonServer) ClaimOnlinePurchase(context.Context, *Empty) (*ClaimOnlinePurchaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimOnlinePurchase not implemented")
}
func (UnimplementedDaemonServer) SetVirtualLocation(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVirtualLocation not implemented")
}
func (UnimplementedDaemonServer) SubscribeToStateChanges(*Empty, Daemon_SubscribeToStateChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToStateChanges not implemented")
}
func (UnimplementedDaemonServer) GetServers(context.Context, *Empty) (*ServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServers not implemented")
}
func (UnimplementedDaemonServer) SetPostQuantum(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPostQuantum not implemented")
}
func (UnimplementedDaemonServer) mustEmbedUnimplementedDaemonServer() {}

// UnsafeDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonServer will
// result in compilation errors.
type UnsafeDaemonServer interface {
	mustEmbedUnimplementedDaemonServer()
}

func RegisterDaemonServer(s grpc.ServiceRegistrar, srv DaemonServer) {
	s.RegisterService(&Daemon_ServiceDesc, srv)
}

func _Daemon_AccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).AccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/AccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).AccountInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_TokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).TokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/TokenInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).TokenInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Cities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Cities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Cities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Cities(ctx, req.(*CitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConnectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).Connect(m, &daemonConnectServer{stream})
}

type Daemon_ConnectServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type daemonConnectServer struct {
	grpc.ServerStream
}

func (x *daemonConnectServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_Countries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Countries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Countries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Countries(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Disconnect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).Disconnect(m, &daemonDisconnectServer{stream})
}

type Daemon_DisconnectServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type daemonDisconnectServer struct {
	grpc.ServerStream
}

func (x *daemonDisconnectServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_Groups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Groups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Groups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Groups(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_IsLoggedIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).IsLoggedIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/IsLoggedIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).IsLoggedIn(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_LoginWithToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginWithTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginWithToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/LoginWithToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginWithToken(ctx, req.(*LoginWithTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_LoginOAuth2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).LoginOAuth2(m, &daemonLoginOAuth2Server{stream})
}

type Daemon_LoginOAuth2Server interface {
	Send(*String) error
	grpc.ServerStream
}

type daemonLoginOAuth2Server struct {
	grpc.ServerStream
}

func (x *daemonLoginOAuth2Server) Send(m *String) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_LoginOAuth2Callback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginOAuth2Callback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/LoginOAuth2Callback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginOAuth2Callback(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Plans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Plans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Plans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Plans(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_RateConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).RateConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/RateConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).RateConnection(ctx, req.(*RateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetAutoConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutoconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetAutoConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetAutoConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetAutoConnect(ctx, req.(*SetAutoconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetThreatProtectionLite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetThreatProtectionLiteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetThreatProtectionLite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetThreatProtectionLite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetThreatProtectionLite(ctx, req.(*SetThreatProtectionLiteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetDefaults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetDefaults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetDefaults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetDefaults(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetDNS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetDNS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetDNS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetDNS(ctx, req.(*SetDNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetFirewall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetFirewall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetFirewall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetFirewall(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetFirewallMark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUint32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetFirewallMark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetFirewallMark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetFirewallMark(ctx, req.(*SetUint32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetRouting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetRouting(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetAnalytics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetAnalytics(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetKillSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKillSwitchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetKillSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetKillSwitch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetKillSwitch(ctx, req.(*SetKillSwitchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNotifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetNotify(ctx, req.(*SetNotifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetTray_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTrayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetTray(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetTray",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetTray(ctx, req.(*SetTrayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetObfuscate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetObfuscate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetObfuscate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetObfuscate(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetProtocol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProtocolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetProtocol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetProtocol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetProtocol(ctx, req.(*SetProtocolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetTechnology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTechnologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetTechnology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetTechnology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetTechnology(ctx, req.(*SetTechnologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetLANDiscovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLANDiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetLANDiscovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetLANDiscovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetLANDiscovery(ctx, req.(*SetLANDiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAllowlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetAllowlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetAllowlist(ctx, req.(*SetAllowlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_UnsetAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAllowlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).UnsetAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/UnsetAllowlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).UnsetAllowlist(ctx, req.(*SetAllowlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_UnsetAllAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).UnsetAllAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/UnsetAllAllowlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).UnsetAllAllowlist(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Settings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Settings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Settings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Settings(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SettingsProtocols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SettingsProtocols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SettingsProtocols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SettingsProtocols(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SettingsTechnologies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SettingsTechnologies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SettingsTechnologies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SettingsTechnologies(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Status(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetIpv6_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetIpv6(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetIpv6",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetIpv6(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ClaimOnlinePurchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ClaimOnlinePurchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/ClaimOnlinePurchase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ClaimOnlinePurchase(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetVirtualLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetVirtualLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetVirtualLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetVirtualLocation(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SubscribeToStateChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).SubscribeToStateChanges(m, &daemonSubscribeToStateChangesServer{stream})
}

type Daemon_SubscribeToStateChangesServer interface {
	Send(*AppState) error
	grpc.ServerStream
}

type daemonSubscribeToStateChangesServer struct {
	grpc.ServerStream
}

func (x *daemonSubscribeToStateChangesServer) Send(m *AppState) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_GetServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/GetServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetServers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetPostQuantum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetPostQuantum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetPostQuantum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetPostQuantum(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Daemon_ServiceDesc is the grpc.ServiceDesc for Daemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Daemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Daemon",
	HandlerType: (*DaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AccountInfo",
			Handler:    _Daemon_AccountInfo_Handler,
		},
		{
			MethodName: "TokenInfo",
			Handler:    _Daemon_TokenInfo_Handler,
		},
		{
			MethodName: "Cities",
			Handler:    _Daemon_Cities_Handler,
		},
		{
			MethodName: "Countries",
			Handler:    _Daemon_Countries_Handler,
		},
		{
			MethodName: "Groups",
			Handler:    _Daemon_Groups_Handler,
		},
		{
			MethodName: "IsLoggedIn",
			Handler:    _Daemon_IsLoggedIn_Handler,
		},
		{
			MethodName: "LoginWithToken",
			Handler:    _Daemon_LoginWithToken_Handler,
		},
		{
			MethodName: "LoginOAuth2Callback",
			Handler:    _Daemon_LoginOAuth2Callback_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Daemon_Logout_Handler,
		},
		{
			MethodName: "Plans",
			Handler:    _Daemon_Plans_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Daemon_Ping_Handler,
		},
		{
			MethodName: "RateConnection",
			Handler:    _Daemon_RateConnection_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _Daemon_Register_Handler,
		},
		{
			MethodName: "SetAutoConnect",
			Handler:    _Daemon_SetAutoConnect_Handler,
		},
		{
			MethodName: "SetThreatProtectionLite",
			Handler:    _Daemon_SetThreatProtectionLite_Handler,
		},
		{
			MethodName: "SetDefaults",
			Handler:    _Daemon_SetDefaults_Handler,
		},
		{
			MethodName: "SetDNS",
			Handler:    _Daemon_SetDNS_Handler,
		},
		{
			MethodName: "SetFirewall",
			Handler:    _Daemon_SetFirewall_Handler,
		},
		{
			MethodName: "SetFirewallMark",
			Handler:    _Daemon_SetFirewallMark_Handler,
		},
		{
			MethodName: "SetRouting",
			Handler:    _Daemon_SetRouting_Handler,
		},
		{
			MethodName: "SetAnalytics",
			Handler:    _Daemon_SetAnalytics_Handler,
		},
		{
			MethodName: "SetKillSwitch",
			Handler:    _Daemon_SetKillSwitch_Handler,
		},
		{
			MethodName: "SetNotify",
			Handler:    _Daemon_SetNotify_Handler,
		},
		{
			MethodName: "SetTray",
			Handler:    _Daemon_SetTray_Handler,
		},
		{
			MethodName: "SetObfuscate",
			Handler:    _Daemon_SetObfuscate_Handler,
		},
		{
			MethodName: "SetProtocol",
			Handler:    _Daemon_SetProtocol_Handler,
		},
		{
			MethodName: "SetTechnology",
			Handler:    _Daemon_SetTechnology_Handler,
		},
		{
			MethodName: "SetLANDiscovery",
			Handler:    _Daemon_SetLANDiscovery_Handler,
		},
		{
			MethodName: "SetAllowlist",
			Handler:    _Daemon_SetAllowlist_Handler,
		},
		{
			MethodName: "UnsetAllowlist",
			Handler:    _Daemon_UnsetAllowlist_Handler,
		},
		{
			MethodName: "UnsetAllAllowlist",
			Handler:    _Daemon_UnsetAllAllowlist_Handler,
		},
		{
			MethodName: "Settings",
			Handler:    _Daemon_Settings_Handler,
		},
		{
			MethodName: "SettingsProtocols",
			Handler:    _Daemon_SettingsProtocols_Handler,
		},
		{
			MethodName: "SettingsTechnologies",
			Handler:    _Daemon_SettingsTechnologies_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Daemon_Status_Handler,
		},
		{
			MethodName: "SetIpv6",
			Handler:    _Daemon_SetIpv6_Handler,
		},
		{
			MethodName: "ClaimOnlinePurchase",
			Handler:    _Daemon_ClaimOnlinePurchase_Handler,
		},
		{
			MethodName: "SetVirtualLocation",
			Handler:    _Daemon_SetVirtualLocation_Handler,
		},
		{
			MethodName: "GetServers",
			Handler:    _Daemon_GetServers_Handler,
		},
		{
			MethodName: "SetPostQuantum",
			Handler:    _Daemon_SetPostQuantum_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _Daemon_Connect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Disconnect",
			Handler:       _Daemon_Disconnect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LoginOAuth2",
			Handler:       _Daemon_LoginOAuth2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToStateChanges",
			Handler:       _Daemon_SubscribeToStateChanges_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}
