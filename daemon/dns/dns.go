/*
Package dns is responsible for configuring dns on various Linux distros.
*/
package dns

import (
	"errors"
	"fmt"
	"log"
	"strings"

	"github.com/NordSecurity/nordvpn-linux/events"
	"github.com/NordSecurity/nordvpn-linux/internal"
)

const (
	dnsPrefix = "[DNS]"
	// resolvconfFilePath defines path to resolv.conf file for DNS
	resolvconfFilePath = "/etc/resolv.conf"

	// comment and link target used to identify NetworkManager managed resolv.conf
	networkManagerComment    = "# Generated by NetworkManager"
	networkManagerLinkTarget = "/run/NetworkManager/resolv.conf"

	// systemdResolvedComment is the comment used to mark resolv.conf managed by systemd-resolved.
	systemdResolvedComment = "# This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8)."

	systemdResolvedLinkTarget = "/run/systemd/resolve/stub-resolv.conf"
)

type dnsManagementService int

const (
	unknownManagementService dnsManagementService = iota
	nmcliManagementService
	systemdResolvedManagementService
	unmanagedManagementService
)

func (e dnsManagementService) String() string {
	switch e {
	case nmcliManagementService:
		return "nmcli"
	case systemdResolvedManagementService:
		return "systemd-resolved"
	case unmanagedManagementService:
		return "unmanaged"
	case unknownManagementService:
		fallthrough
	default:
		return "unknown_service"
	}
}

var ErrDNSNotSet = errors.New("DNS unsetter not set")

// Setter is responsible for configuring DNS.
type Setter interface {
	Set(iface string, nameservers []string) error
	Unset(iface string) error
}

// Method is abstraction of DNS handling method
type Method interface {
	Set(iface string, nameservers []string) error
	Unset(iface string) error
	Name() string
}

// DNSServiceSetter detects how OS is managing the DNS configuration and tries to set it using the appropriate method.
type DNSServiceSetter struct {
	// systemdResolvedSetter sets DNS using the most desired method:
	// 	1. systemd-resolved DBUS
	// 	2. resolvectl exec call
	systemdResolvedSetter Setter
	// nmcliSetter sets DNS using NetworkManager CLI tool
	nmcliSetter Setter
	// resolvconfSetter sets DNS using the most desired method:
	//	1. resolvconf exec call
	//	2. direct write to /etc/resolv.conf
	resolvconfSetter  Setter
	unsetter          Setter
	filesystemHandle  internal.FileSystemHandle
	analytics         analytics
	resolvConfMonitor resolvConfMonitor
}

func NewDNSServiceSetter(debugPublisher events.PublishSubcriber[events.DebuggerEvent]) *DNSServiceSetter {
	analytics := newDNSAnalytics(debugPublisher)
	resolvConfMonitor := newResolvConfMonitor(analytics)
	return &DNSServiceSetter{
		systemdResolvedSetter: NewSetter(&Resolved{}, &Resolvectl{}),
		resolvconfSetter:      NewSetter(&Resolvconf{}, &ResolvConfFile{}),
		nmcliSetter:           NewSetter(newNMCli()),
		filesystemHandle:      internal.StdFilesystemHandle{},
		analytics:             analytics,
		resolvConfMonitor:     &resolvConfMonitor,
	}
}

func (d *DNSServiceSetter) getManagementServiceBasedOnResolvconfComment() (dnsManagementService, error) {
	resolvConfFileContents, err := d.filesystemHandle.ReadFile(resolvconfFilePath)
	if err != nil {
		return unknownManagementService, fmt.Errorf("reading resolv.conf file: %w", err)
	}

	if strings.Contains(string(resolvConfFileContents), systemdResolvedComment) {
		return systemdResolvedManagementService, nil
	}

	if strings.Contains(string(resolvConfFileContents), networkManagerComment) {
		return nmcliManagementService, nil
	}

	return unknownManagementService, fmt.Errorf("comment not found or not recognized")
}

func (d *DNSServiceSetter) getManagementServiceBasedOnResolvconfLinkTarget() (dnsManagementService, error) {
	resolvConfFileInfo, err := d.filesystemHandle.Stat(resolvconfFilePath)
	if err != nil {
		return unknownManagementService, fmt.Errorf("failed to stat /etc/resolv.conf: %w", err)
	}

	if systemdResolvedFileInfo, err := d.filesystemHandle.Stat(systemdResolvedLinkTarget); err != nil {
		log.Println(internal.WarningPrefix, dnsPrefix, "failed to stat systemd-resolved stub:", err)
	} else if d.filesystemHandle.SameFile(resolvConfFileInfo, systemdResolvedFileInfo) {
		return systemdResolvedManagementService, nil
	}

	if nmcliFileInfo, err := d.filesystemHandle.Stat(networkManagerLinkTarget); err != nil {
		log.Println(internal.WarningPrefix, dnsPrefix, "failed to stat NetworkManager resolv.conf:", err)
	} else if d.filesystemHandle.SameFile(resolvConfFileInfo, nmcliFileInfo) {
		return nmcliManagementService, nil
	}

	return unknownManagementService, fmt.Errorf("link target not recognized")
}

func (d *DNSServiceSetter) getManagementService() dnsManagementService {
	managementService, err := d.getManagementServiceBasedOnResolvconfComment()
	if err == nil {
		log.Println(internal.InfoPrefix, dnsPrefix, "management service inferred from resolv.conf comment")
		return managementService
	}

	log.Println(internal.WarningPrefix, dnsPrefix, "couldn't determine management service based on resolv.conf comment:", err)
	managementService, err = d.getManagementServiceBasedOnResolvconfLinkTarget()
	if err == nil {
		log.Println(internal.InfoPrefix, dnsPrefix, "management service inferred from link target")
		return managementService
	}
	log.Println(internal.ErrorPrefix, dnsPrefix, "couldn't determine management service based on resolv.conf link target:", err)

	//this is effectively `unknown`, see getManagementServiceBasedOnResolvconfLinkTarget for details (it returns unknown upon an error)
	return managementService
}

// set sets DNS using the provided setter and sets a matching unsetter if the operation was successful
func (d *DNSServiceSetter) set(setter Setter, iface string, nameservers []string) error {
	err := setter.Set(iface, nameservers)
	if err != nil {
		return fmt.Errorf("failed to set DNS: %w", err)
	}

	d.unsetter = setter
	d.analytics.emitDNSConfiguredEvent()

	return nil
}

// setUsingAvailable sets DNS using the first setter in the bellow priority list:
//  1. systemd-resolved DBUS
//  2. resolvctl utility
//  3. NetworkManager nmcli tool
//  4. resolv.conf utility
//  5. direct write to resolv.conf
func (d *DNSServiceSetter) setUsingAvailable(iface string, nameservers []string) error {
	if err := d.set(d.systemdResolvedSetter, iface, nameservers); err != nil {
		log.Println(internal.WarningPrefix, dnsPrefix,
			"failed to configure DNS using systemd-resolved, attempting with nmcli: %w", err)
	} else {
		d.analytics.setManagementService(systemdResolvedManagementService)
		log.Println(internal.InfoPrefix, dnsPrefix, "DNS configured with systemd-resolved")
		return nil
	}

	if err := d.set(d.nmcliSetter, iface, nameservers); err != nil {
		log.Println(internal.WarningPrefix, dnsPrefix,
			"failed to configure DNS using nmcli, attempting with resolv.conf, %w", err)
	} else {
		d.analytics.setManagementService(nmcliManagementService)
		log.Println(internal.InfoPrefix, dnsPrefix, "DNS configured with nmcli")
		return nil
	}

	d.analytics.setManagementService(unmanagedManagementService)
	if err := d.set(d.resolvconfSetter, iface, nameservers); err != nil {
		return fmt.Errorf("failed to configure DNS with resolv.conf: %w", err)
	}

	log.Println(internal.InfoPrefix, dnsPrefix, "DNS configured with resolv.conf")
	d.resolvConfMonitor.start()

	return nil
}

// Set sets the DNS using the most appropriate method, it attempts to:
//  1. Infer which method to use from the comment in /etc/resolv.conf
//     1a. If systemd-resolved is detected, it tries to set DNS using systemd-resolved handler
//     1b. If network manager is detected, it tries to set DNS using nmcli handler
//  2. If the above fails, infer which method to use based on /etc/resolv.conf link target
//     2a. If systemd-resolved sym-link is detected, it tries to set DNS using systemd-resolved handler
//     2b. If network manager sym-link is detected, it tries to set DNS using nmcli handler
//  3. If the above fails, it attempts to use best available method(see setUsingAvailable)
//  4. If all of the above fail, it returns an error
func (d *DNSServiceSetter) Set(iface string, nameservers []string) error {
	// stop resolv.conf monitoring in case it is already running
	d.resolvConfMonitor.stop()

	managementService := d.getManagementService()
	d.analytics.setManagementService(managementService)
	switch managementService {
	case systemdResolvedManagementService:
		log.Println(internal.InfoPrefix, dnsPrefix, "setting DNS using systemd-resolved")
		err := d.set(d.systemdResolvedSetter, iface, nameservers)
		if err == nil {
			return nil
		}
		log.Println(internal.WarningPrefix, dnsPrefix, "failed to set DNS using systemd-resolved:", err)
	case nmcliManagementService:
		log.Println(internal.InfoPrefix, dnsPrefix, "setting DNS using NetworkManager nmcli tool")
		err := d.set(d.nmcliSetter, iface, nameservers)
		if err == nil {
			return nil
		}
		log.Println(internal.WarningPrefix, dnsPrefix, "failed to set DNS using nmcli:", err)
	case unmanagedManagementService:
		fallthrough
	case unknownManagementService:
		fallthrough
	default:
		log.Println(internal.WarningPrefix, dnsPrefix, "unknown DNS service")
	}

	log.Println(internal.InfoPrefix, dnsPrefix, "attempting to set DNS using available methods")
	if err := d.setUsingAvailable(iface, nameservers); err != nil {
		return fmt.Errorf("failed to set DNS using available methods: %w", err)
	}

	return nil
}

// Unset unsets the DNS using the same family of methods that was used to set it
func (d *DNSServiceSetter) Unset(iface string) error {
	if d.unsetter == nil {
		return ErrDNSNotSet
	}

	d.resolvConfMonitor.stop()
	if err := d.unsetter.Unset(iface); err != nil {
		return fmt.Errorf("unsetting DNS: %w", err)
	}

	return nil
}

// DNSMethodSetter iterates over the list of DNS configuration methods and tries to apply the desired DNS config with each of
// them.
type DNSMethodSetter struct {
	methods []Method
}

func NewSetter(methods ...Method) *DNSMethodSetter {
	ds := DNSMethodSetter{
		methods: methods,
	}

	return &ds
}

// Set DNS for a given iface if the system supports per interface DNS settings.
// Also, backup current DNS settings (only in case of direct resolv.conf edit).
// Backup is not overridden, so its safe to call this function multiple times in a row.
func (d *DNSMethodSetter) Set(iface string, nameservers []string) error {
	log.Println(internal.InfoPrefix, dnsPrefix, "setting dns to "+strings.Join(nameservers, " "))

	if len(nameservers) == 0 {
		return errors.New("nameservers not provided")
	}

	for _, method := range d.methods {
		log.Println(internal.InfoPrefix, dnsPrefix, "Set on interface ["+iface+"] using: ", method.Name())
		if err := method.Set(iface, nameservers); err != nil {
			log.Println(internal.ErrorPrefix, fmt.Errorf("setting dns with %s: %w", method.Name(), err))
			continue
		}

		return nil
	}

	return fmt.Errorf("dns not set, no dns setting method is available")
}

// Unset DNS for network interface, restore DNS from a backup, if backup
// is available, and remove the backup on success.
func (d *DNSMethodSetter) Unset(iface string) error {
	for _, method := range d.methods {
		log.Println(internal.InfoPrefix, dnsPrefix, "Unset on interface ["+iface+"] using: ", method.Name())
		if err := method.Unset(iface); err != nil {
			log.Println(internal.ErrorPrefix, fmt.Errorf("unsetting dns with %s: %w", method.Name(), err))
			continue
		}
		return nil
	}
	return nil
}

// RestoreResolvConfFile try to restore resolv.conf if target file contains Nordvpn changes
func RestoreResolvConfFile() {
	tryToRestoreDNS()
}
