package dns

import (
	"fmt"
	"log"
	"path/filepath"
	"strings"

	"github.com/NordSecurity/nordvpn-linux/internal"
)

// Files
const (
	// resolvconfFilePath defines path to resolv.conf file for DNS
	resolvconfFilePath = "/etc/resolv.conf"
)

var (
	// resolvconfBackupPath defines where resolv.conf backup file is stored
	resolvconfBackupPath = filepath.Join(internal.BakFilesPath, "resolv.conf")
)

// Direct file resolv.conf editing based DNS handling method.
// This is last fallback method if others are not available
type ResolvConfFile struct{}

func (m *ResolvConfFile) Set(iface string, nameservers []string) error {
	return setDNSinResolvconfFile(nameservers)
}

func (m *ResolvConfFile) Unset(iface string) error {
	return unsetDNSinResolvconfFile()
}

func (m *ResolvConfFile) IsAvailable() bool {
	return internal.FileExists(resolvconfFilePath)
}

func (m *ResolvConfFile) Name() string {
	return "resolv.conf, default"
}

func setDNSinResolvconfFile(addresses []string) error {
	if internal.FileExists(resolvconfFilePath) {
		if !internal.FileWritable(resolvconfFilePath) {
			log.Println(internal.WarningPrefix, "dns not set, resolv.conf file is not writable")
			return nil
		}
	}
	err := backupDNS()
	if err != nil {
		return fmt.Errorf("backing up dns: %w", err)
	}
	return resetDNSinResolvconfFile(addresses)
}

func resetDNSinResolvconfFile(addresses []string) error {
	var addrs = make([]string, len(addresses))
	for idx, address := range addresses {
		addrs[idx] = "nameserver " + address
	}

	// set DNS
	_ = internal.FileUnlock(resolvconfFilePath)
	defer internal.FileLock(resolvconfFilePath)
	content := "# Generated by NordVPN\n" + strings.Join(addrs, "\n")
	return internal.FileWrite(resolvconfFilePath, []byte(content), internal.PermUserRWGroupROthersR)
}

func unsetDNSinResolvconfFile() error {
	out, err := internal.FileRead(resolvconfFilePath)
	if err != nil {
		return fmt.Errorf("reading resolv.conf: %w", err)
	}
	if strings.Contains(string(out), "Generated by NordVPN") {
		_ = internal.FileUnlock(resolvconfFilePath)
		return restoreDNS()
	}
	return nil
}

func backupDNS() error {
	if internal.FileExists(resolvconfBackupPath) {
		return nil
	}
	out, err := internal.FileRead(resolvconfFilePath)
	if err != nil {
		return fmt.Errorf("reading resolv.conf: %w", err)
	}
	return internal.FileWrite(resolvconfBackupPath, out, internal.PermUserRWGroupROthersR)
}

func restoreDNS() error {
	defer internal.FileDelete(resolvconfBackupPath)
	out, err := internal.FileRead(resolvconfBackupPath)
	if err != nil {
		return fmt.Errorf("reading resolv.conf backup: %w", err)
	}
	return internal.FileWrite(resolvconfFilePath, out, internal.PermUserRWGroupROthersR)
}
