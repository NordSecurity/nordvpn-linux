package dns

import (
	"fmt"
	"log"
	"net"
	"net/netip"
	"path/filepath"
	"strings"

	"github.com/NordSecurity/nordvpn-linux/daemon/routes/netlink"
	"github.com/NordSecurity/nordvpn-linux/internal"
)

// Files
const (
	// resolvconfFilePath defines path to resolv.conf file for DNS
	resolvconfFilePath = "/etc/resolv.conf"
	// resolvconfFileMark mark resolv.conf file content to recorgnize
	resolvconfFileMark = "# Generated by NordVPN"
	// resolvconfFileContent is simple dns settings to restore as a last option
	resolvconfFileContent = "#restored\nnameserver %s\n"
)

var (
	// resolvconfBackupPath defines where resolv.conf backup file is stored
	resolvconfBackupPath = filepath.Join(internal.BakFilesPath, "resolv.conf")
)

// Direct file resolv.conf editing based DNS handling method.
// This is last fallback method if others are not available
type ResolvConfFile struct{}

func (m *ResolvConfFile) Set(iface string, nameservers []string) error {
	return setDNSinResolvconfFile(nameservers)
}

func (m *ResolvConfFile) Unset(iface string) error {
	return unsetDNSinResolvconfFile()
}

func (m *ResolvConfFile) Name() string {
	return "resolv.conf, default"
}

func setDNSinResolvconfFile(addresses []string) error {
	if internal.FileExists(resolvconfFilePath) {
		if out, err := internal.FileRead(resolvconfFilePath); err == nil &&
			strings.Contains(string(out), resolvconfFileMark) {
			// while connected to vpn, dns may be changed then need
			// to rewrite file with new nameservers - need to check
			// if target file contains our mark and that means is locked by us
		} else {
			if internal.IsFileLocked(resolvconfFilePath) {
				// here we assume file is locked by user and we respect that
				log.Println(internal.WarningPrefix, "dns not set, resolv.conf file is locked (immutable)")
				return nil
			}
		}
		if !internal.FileWritable(resolvconfFilePath) {
			log.Println(internal.WarningPrefix, "dns not set, resolv.conf file is not writable")
			return nil
		}
	}
	err := backupDNS()
	if err != nil {
		return fmt.Errorf("backing up dns: %w", err)
	}
	return resetDNSinResolvconfFile(addresses)
}

func resetDNSinResolvconfFile(addresses []string) error {
	var addrs = make([]string, len(addresses))
	for idx, address := range addresses {
		addrs[idx] = "nameserver " + address
	}

	// set DNS
	_ = internal.FileUnlock(resolvconfFilePath)
	defer internal.FileLock(resolvconfFilePath)
	content := resolvconfFileMark + "\n" + strings.Join(addrs, "\n") + "\n"
	return internal.FileWrite(resolvconfFilePath, []byte(content), internal.PermUserRWGroupROthersR)
}

func unsetDNSinResolvconfFile() error {
	out, err := internal.FileRead(resolvconfFilePath)
	if err != nil {
		return fmt.Errorf("reading resolv.conf: %w", err)
	}
	if strings.Contains(string(out), resolvconfFileMark) {
		_ = internal.FileUnlock(resolvconfFilePath)
		return restoreDNS()
	}
	return nil
}

func backupDNS() error {
	if internal.FileExists(resolvconfBackupPath) {
		return nil
	}
	out, err := internal.FileRead(resolvconfFilePath)
	if err != nil {
		return fmt.Errorf("reading resolv.conf: %w", err)
	}
	return internal.FileWrite(resolvconfBackupPath, out, internal.PermUserRWGroupROthersR)
}

func restoreDNS() error {
	if err := restoreFromBackup(); err != nil {
		log.Println(internal.WarningPrefix, fmt.Errorf("failed restoring resolv.conf from backup: %w", err))
		restoreWithSimpleSettings()
	}
	return nil
}

func tryToRestoreDNS() {
	// if target is symlink, probably it is managed by other software - do nothing
	if internal.IsSymLink(resolvconfFilePath) {
		return
	}
	// if target /etc/resolv.conf contains nordvpn changes:
	// if possible restore from backup
	// if backup does not exists, create simple dns settings file
	out, err := internal.FileRead(resolvconfFilePath)
	if err != nil {
		log.Println(internal.ErrorPrefix, fmt.Errorf("reading resolv.conf: %w", err))
		return
	}
	if !strings.Contains(string(out), resolvconfFileMark) {
		return
	}

	log.Println(internal.WarningPrefix, "/etc/resolv.conf contains our changes - need to fix this")

	// try to unlock, if file contains our changes - it was locked by us
	_ = internal.FileUnlock(resolvconfFilePath)

	if err := restoreFromBackup(); err != nil {
		log.Println(internal.WarningPrefix, fmt.Errorf("failed restoring resolv.conf from backup: %w", err))
		restoreWithSimpleSettings()
	}
}

func restoreFromBackup() error {
	// restore from backup if backup file exists
	if internal.FileExists(resolvconfBackupPath) {
		backup, err := internal.FileRead(resolvconfBackupPath)
		// try to remove backup
		_ = internal.FileDelete(resolvconfBackupPath)
		if err != nil {
			return fmt.Errorf("reading backup resolv.conf: %w", err)
		} else {
			// last check if backup does not have our changes
			if strings.Contains(string(backup), resolvconfFileMark) {
				return fmt.Errorf("resolv.conf backup contains our changes - do not restore from it")
			} else {
				if err := internal.FileWrite(resolvconfFilePath, backup, internal.PermUserRWGroupROthersR); err != nil {
					return fmt.Errorf("restore from backup resolv.conf: %w", err)
				} else {
					// succeeded with backup restore
					return nil
				}
			}
		}
	}
	return fmt.Errorf("resolv.conf backup not found")
}

func restoreWithSimpleSettings() {
	// there is no backup, but we need to fix dns settings
	ip, err := discoverNameserverIp()
	if err != nil {
		log.Println(internal.ErrorPrefix, fmt.Errorf("discovering nameserver: %w", err))
		// this is very-very last option and hope this will not happen
		ip = netip.MustParseAddr("1.1.1.1")
	}

	log.Println(internal.WarningPrefix, "/etc/resolv.conf restore with nameserver:", ip)

	content := fmt.Sprintf(resolvconfFileContent, ip)
	if err := internal.FileWrite(resolvconfFilePath, []byte(content), internal.PermUserRWGroupROthersR); err != nil {
		log.Println(internal.ErrorPrefix, fmt.Errorf("writing simple resolv.conf: %w", err))
	}
}

func discoverNameserverIp() (netip.Addr, error) {
	// 1st try: 127.0.0.53:53
	// then: GW
	nsIp := netip.MustParseAddr("127.0.0.53")
	con, err := net.ListenPacket("udp", nsIp.String()+":53")
	if err != nil && strings.Contains(err.Error(), "address already in use") {
		// assume this local address+port is nameserver
		return nsIp, nil
	}
	if err == nil && con != nil {
		_ = con.Close()
	}

	ip, err := findGateway()
	if err != nil {
		return netip.Addr{}, err
	}

	return ip, nil
}

func findGateway() (netip.Addr, error) {
	gw, _, err := netlink.Retriever{}.Retrieve(netip.MustParsePrefix("0.0.0.0/0"), 0)
	if err != nil {
		return netip.Addr{}, err
	}

	return gw, nil
}
